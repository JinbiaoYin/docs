# 单例和多例

单例模式类的对象在整个系统只有一个，而多例模式类的对象可以有多个。
`Spring`的`IOC`容器管理的`bean`默认是单实例的，可以通过`@Scope(value="prototype")`将类改为多例模式。两者的区别如何体现呢。

## 单例与多例的区别
如果一个bean被声明为单例的时候，在处理多次请求的时候，在spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候，会先从缓存（map）里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。但是对于原型（prototype）bean来说，当每次请求来的时候，会直接实例化新的bean，没有缓存以及缓存查询的过程。

## 一个例子体现单例模式和多例模式的不同
首先是单例：
```java
@Controller
@RequestMapping("/singleton")
public class SingletonController{

    private int i = 0;

    @GetMapping("/test")
    public void test(){
        i++;
        System.out.println(i);
    }
    
}
```
结果：  
第一次调用：1，第二次调用：2，第三次调用：3。说明每个请求进来，不会重新`new`一个新的对象，i只有一份。

改为多例模式：
```java
@Controller
@RequestMapping("/singleton")
@Scope(value="prototype")
public class SingletonController{

    private int i = 0;

    @GetMapping("/test")
    public void test(){
        i++;
        System.out.println(i);
    }
    
}
```
结果：  
第一次调用：1，第二次调用：1，第三次调用：1。多例模式下每次请求进来都会`new`一个新的对象。


## 单例的好处和坏处
好处：
- 减少新生成实例的消耗。新生成实例包括两个方面，第一，spring会通过反射或者cglib来生成bean实例，这都是耗性能的操作。第二，给对象分配内存也会涉及负责算法。
- 减少jvm垃圾回收。由于不会给每个请求都生成bean实例，所以回收的对象就少了。
- 可以快速获取到bean。因为单例获取bean操作，除了第一次生成之外，其余都是从缓存里获取的，所以很快。

坏处:
一个很大的劣势是它不能做到线程安全。由于所有请求都共享一个bean实例，那么如果这个bean是一个有状态的bean的话，在并发场景下就有可能出现问题。

## 单例模式的线程安全
当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求所对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题（此时该状态就是一个临界资源（共享数据），如果多个线程同时操作（修改）这个临界资源就会诱发线程安全问题）。

**线程安全问题都是由全局变量及静态变量引起的。**

若每个线程中对全局变量，静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

- 常量始终是线程安全的，因为只存在读操作；
- 每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源；
- 局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享资源。局部变量包括方法的参数变量和方法内的变量。

**如何解决线程安全问题**
1. 使用线程同步机制：通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序缜密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂问题，程序设计和编写难度相对较大。
2. 使用ThreadLocal：为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。

概括起来就是：对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。